<?php

namespace App\Tests;

use Symfony\Bundle\FrameworkBundle\Test\KernelTestCase;
use Symfony\Component\VarDumper\Test\VarDumperTestTrait;
use Symfony\Component\Serializer\Encoder\JsonEncoder;
use Symfony\Component\Serializer\Normalizer\ArrayDenormalizer;
use Symfony\Component\Serializer\Normalizer\DateTimeNormalizer;
use Symfony\Component\Serializer\Normalizer\PropertyNormalizer;
use Symfony\Component\Serializer\Serializer;

/**
 * Class ParentTestCase
 * @package App\Tests
 */
class ParentTestCase extends KernelTestCase
{
    use VarDumperTestTrait;

    /** @var string */
    protected $inputResourceMiddlePath;

    /** @var string */
    protected $outputResourceMiddlePath;

    /**
     *
     */
    protected function tearDown(): void
    {
        parent::tearDown(); // TODO: Change the autogenerated stub
    }


    /* ************** GLOBAL TEST METHODS ************** */

    /**
     * Checks if all getters are present for an object
     * @param $obj
     * @return array
     * @throws \ReflectionException
     */
    protected function checkGettersOfAllAttributes($obj)
    {
        $missingMethods = [];
        $reflect = new \ReflectionClass(get_class($obj));
        foreach ($reflect->getProperties() as $prop) {
            $name = $prop->getName();
            $method = "get" . ucfirst($name);
            if (!method_exists($obj, $method)) {
                $missingMethods[] = $method;
            }
            try {
                $obj->$method();
            } catch (\Exception $e) {
                $missingMethods[] = $method;
            }

        }
        return $missingMethods;
    }

    /* ************** HELPERS ************** */

    /**
     * Assert
     * @param array $expected
     * @param array $actual
     * @param bool $ordering
     */
    protected function assertArrayEquals(?array $expected, ?array $actual, $ordering = true)
    {
        if ($ordering) {
            sort($expected);
            sort($actual);
        }
        $this->assertEquals($expected, $actual);
    }

    /**
     * @param string $filename
     * @return array
     */
    protected function loadJsonFromInputResources(string $filename): array
    {
        $filenameComplete = (strstr($filename, '.json') === false) ? $filename . '.json' : $filename;
        return json_decode(
            file_get_contents(__DIR__ . '/Resources/' . $this->inputResourceMiddlePath . $filenameComplete),
            true
        );
    }

    /**
     * @param string $filename
     * @return array
     */
    protected function loadJsonFromOutputResources(string $filename): array
    {
        $filenameComplete = (strstr($filename, '.json') === false) ? $filename . '.json' : $filename;
        return json_decode(
            file_get_contents(__DIR__ . '/Resources/' . $this->outputResourceMiddlePath . $filenameComplete),
            true
        );
    }

    /**
     * @param string $filename
     * @return mixed
     */
    protected function loadObjectFromInputResources(string $filename)
    {
        return unserialize(
            file_get_contents(__DIR__ . '/Resources/' . $this->inputResourceMiddlePath . $filename)
        );
    }

    /**
     * @param $filename
     * @return string
     */
    protected function createOutputJsonPath($filename): string
    {
        $filenameComplete = (strstr($filename, '.json') === false) ? $filename . '.json' : $filename;
        return __DIR__ . '/Resources/' . $this->outputResourceMiddlePath . $filenameComplete;
    }

    /**
     * Encode complex object to JSON
     * @param $object
     * @param $options
     * @return bool|float|int|string
     */
    protected function encodeObjectJson($object, $options = [])
    {
        $encoders = [new JsonEncoder()];
        $normalizers = [new PropertyNormalizer(), new ArrayDenormalizer(), new DateTimeNormalizer()];
        $serializer = new Serializer($normalizers, $encoders);
        $json = $serializer->serialize($object, 'json');
        if (array_key_exists('excluded', $options)) {
            $json = json_decode($json, true);
            $filtered = array();
            foreach ($json as $attribute => $value) {
                if (!in_array($attribute, $options['excluded'])) {
                    $filtered[$attribute] = $value;
                }
            }
            $json = json_encode($filtered);
        } elseif (array_key_exists('included', $options)) {
            $json = json_decode($json, true);
            $json = json_encode($this->selectAttributesArrayRecursive($json, $options['included']));
        }
        return $json;
    }

    /**
     * Decode complex JSON to object
     * @param $json
     * @param $objectClass
     * @return object
     */
    protected function decodeObjectJson($json, $objectClass)
    {
        $encoders = [new JsonEncoder()];
        $normalizers = [new PropertyNormalizer(), new ArrayDenormalizer(), new DateTimeNormalizer()];
        $serializer = new Serializer($normalizers, $encoders);
        return $serializer->deserialize($json, $objectClass, 'json');
    }

    /**
     * Transform complex object to simple array using JSON
     * @param $complexObject
     * @return mixed
     */
    protected function transformComplexObjectToArray($complexObject)
    {
        $jsonComplexObject = $this->encodeObjectJson($complexObject);
        return json_decode($jsonComplexObject, true);
    }

    /**
     * Select attributes from array
     * @param $object
     * @param $attributes
     * @return array
     */
    private function selectAttributesArrayRecursive($object, $attributes)
    {
        $isAssoc = !(array() == $attributes) && (array_keys($attributes) !== range(0, count($attributes) - 1));

        if (!$isAssoc) {
            if (is_null($object)) {
                return null;
            }
            $constructed = array();
            foreach ($attributes as $attribute) {
                if (array_key_exists($attribute, $object)) {
                    $constructed[$attribute] = $object[$attribute];
                }
            }
            return $constructed;
        }

        $constructed = array();
        foreach ($attributes as $key => $value) {
            if ($key == '\*') {
                foreach (array_keys($object) as $subKey) {
                    $constructed[$subKey] = $this->selectAttributesArrayRecursive($object[$subKey], $value);
                }
            } else {
                if (array_key_exists($key, $object)) {
                    $constructed[$key] = $this->selectAttributesArrayRecursive($object[$key], $value);
                }
            }
        }
        return $constructed;
    }

    /**
     * Call protected/private method of a class.
     *
     * @param object &$object Instantiated object that we will run method on.
     * @param string $methodName Method name to call
     * @param array $parameters Array of parameters to pass into method.
     *
     * @return mixed Method return.
     * @throws \Exception
     */
    protected function invokeMethod(&$object, $methodName, array $parameters = array())
    {
        $reflection = new \ReflectionClass(get_class($object));
        $method = $reflection->getMethod($methodName);
        $method->setAccessible(true);

        return $method->invokeArgs($object, $parameters);
    }

    /**
     * Get value of a private property of an object
     *
     * @param $object
     * @param $propertyName
     * @param int $filter
     * @return mixed
     * @throws \ReflectionException
     */
    protected function getPrivatePropertyValue($object, $propertyName, $filter = \ReflectionProperty::IS_PRIVATE)
    {
        $reflect = new \ReflectionClass(get_class($object));
        $prop = $reflect->getProperty($propertyName);
        $prop->setAccessible(true);
        return $prop->getValue($object);
    }

    /**
     * Get value of a private property of an object
     *
     * @param $object
     * @param $propertyName
     * @param mixed $value
     * @return mixed
     * @throws \ReflectionException
     */
    protected function setPrivatePropertyValue($object, $propertyName, $value)
    {
        $reflect = new \ReflectionClass(get_class($object));
        $prop = $reflect->getProperty($propertyName);
        $prop->setAccessible(true);
        $prop->setValue($object, $value);
    }
}